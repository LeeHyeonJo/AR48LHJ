// 23_que.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
// 자료구조3: 스택과 반대인 구조, 큐! 

#include <iostream>

// ** 큐 **
// 정의: 한 줄 서기와 동일. 먼저 들어온 데이터가, 먼저 사라진다.
// first in -> first out (선입선출) 구조. 
// 특징; 순서가 중요. 들어온 순서대로 해결하는 구조이다. 

// 게임에서 "큐"를 잡는다고 할때, 그게 이 "큐"임. (들어오는 순서대로 매칭 잡혀야 하니까) 
// 주로 서버가 많은 데이터를 "큐" 를 사용해서 처리함. 
// **이유: 동시 접속한 여러명의 유저(+수십개로 들어오는 데이터들)를 처리해야할 떄. 
// **먼저 들어온 캐릭터의 공격 데이터가 먼저 처리되어야 하기 떄문. 이것을 "메세지 큐" 라고 함. 
// 따라서 각 유저가 보낸 순서보다, "서버에 닿는 순서대로 큐에 기록" 되므로, 닿는 순서가 중요하다.
// 들어오는대로 서버의 큐에 저장되고, 가장 앞에서부터 하나씩 빼서 사용하게 된다. 


// << 템플릿 을 사용해서 구현!!>>: 클래스에선 다른 자료형을 구현하려고 할 떄마다, 그 갯수만큼 함수가 늘어나기 때문

// ** 탬플릿 클래스 **
// 어떤 자료형이든 템플릿을 이용해서 구현하면, 해당 자료형을 명시해주므로서 각 자료형의 클래스가 작성된다. 


// ** 배열로 큐를 만드는 방법 ** + 탬플릿 클래스 

// 1. 템플릿 클래스 구현 

template <typename T> // 일단 선언, 타입 네임(그릇으로 쓸거) 
class qu
{
public:
    qu()
        : mdata{}, // 배열을 생성자에서 초기화할때는 {} 이렇게. 
        : mfrontindex(0), // 배열의 가장 앞 인덱스 이용해서 가장 앞의 값을 불러오고, 가장 앞의 값을 해제함. 
        : mendindex(0) // 배열의 가장 뒤 인덱스를 이용해서 node 추가를 구현함. 
    {
        // 0. 생성자에서 클래스 qu의 멤버 변수들 초기화. (멤버 이니셜라이저)  
    }

    void push(T data) // 1. 배열 맨 뒤에 데이터가 들어오는 함수 
        // 들어오는 데이터의 자료형을 템플릿으로 구현했으므로, 자료형은 T
    {
        mdata[mendindex] = data; 
        mendindex++;
    }

    T tpop() // 2. 배열 맨 앞의 데이터를 리턴 & 맨 앞의 데이터를 해제(원리: froint index 한칸 이동) //top+pop
        // 들어오는 데이터의 자료형을 템플릿으로 구현했으므로, 자료형은 T
    {
        return mdata [mfrontindex++];
        // 우선 맨 앞의 데이터를 리턴한 후
        // 후위연산자를 이용해, frontindex를 한 칸 우측으로 옮겨줌. 
    }

private:
    T mdata[256]; 
    int mfrontindex; // 배열의 제일 앞을 가리키는 인덱스 
    int memdindex; // 배열의 제일 뒤를 기리키는 인덱스 
};


int main()
{
    //2. 템플릿 클래스 사용 예
    // qu<int> num;
    // qu<char> ch;

    qu<int> queue;
    queue.push(1); 
    queue.push(2); 
    queue.push(3); 
    queue.push(4); 

    int pop = queue.tpop();

    //Queue<char> queue;


    return 0;

}

