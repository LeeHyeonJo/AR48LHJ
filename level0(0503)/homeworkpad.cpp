//7번
// 이차원 배열을 함수로 넘겨주기 (복습) 
#include <iostream>
void Magic(int (*pointer)[3]) //  int* 타입의 주소를 받을 수 있는, 주소 저장 포인터로 인자를 선언해야 함. 
{
	int i = 1;
	for (int y = 0; y < 3; y++)
	{
		for (int x = y; x < 3; x++)
		{
			Arr[y][x] = i++;
		}
	}
}

void output(int Arr[3][3])
{
	for (int y = 0; y < 3; y++)
	{
		for (int x = 0; x < 3; x++)
		{
			if (Arr[y][x] == 0)
			{
				std::cout << ' ';
			}
			else
			{
				std::cout << Arr[y][x];
			}
		}
		std::cout << std::endl;
	}
}


int main()
{
	int arr[3][3] = {};
	Magic(&arr[0][0]); // int* 타입의 주소 
	output(&arr[0][0]); // int* 타입의 주소 

	// <-> 일차원&이차원 배열을 함수로 넘겨주기 
		 // = &arr[0] / arr
	// <-> 일차원&이차원 배열을 받아줄때 
		// 1. 일차원
		// (int* Arr) or (int Arr[3])
		// 2. 이차원
		// (int Arr[3][3]) or 배열포인터 (int(*pointer)[3])
		// ->> int* Arr이 안되는것에 주의 
}
// 복습: 이차원 배열을 함수로 넘겨줄때 표기법
// 일차원 배열을 넘겨줄때와의 차이점 
// 질문: 이차원 배열을 함수에서 인자로 받아줄때, “배열 포인터” 가 무엇인지 개념다시 질문. 

	// <-> 일차원&이차원 배열을 함수로 넘겨주기 
		 // 1. 일차원 = &arr[0] / arr
		 // 2. 이차원 = &arr[0][0] / arr
	// <-> 일차원&이차원 배열을 받아줄때 
		// 1. 일차원
		// (int* Arr : int* 타입) or (int Arr[3] : 배열형식)
		// 2. 이차원
		// (int(*pointer)[3] : int* 타입) / (int Arr[3][3] : 배열 형식)

// **함수 인자의 호환성** (1은 1로, 2는 2로 받아주어야 한다) 
// <main->함수로 전달>
// 1. &arr[0] or &arr[0][0] = 선언한 배열의 자료형* 타입(ex int* 타입) (주소를 저장하는 포인터) 
// 2. arr = 배열 형식 
// 
// <함수에서 받음> 
// 1. 자료형(*pointer)[x축] = x축 한 줄을 가리키는 포인터. pointer가 이동하면서 그 아래 줄에 접근하는 식으로
// ㄴpointer가 이동하면서 그 아래 줄에 접근하는 식으로 이차원 배열의 각 행에 접근할 수 있다. 
// 2. Arr[3] or Arr[3][3]: 배열 형식 

// ** int (*pointer)[3]에서 [3]은 배열의 x축(가로)을 의미.
// => 크기가 3인 int 포인터 배열
// 3개의 int 값으로 이루어진 1차원 배열 (가로 한 행) 을 나타냄
// >>> 주소를 저장하는 포인터, 각 포인터가 가리키는 배열은 하나의 가로줄
// >>> pointer를 이용해 2차원 배열의 각 행에 접근할 수 있다. 