// 19_Class.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
// ** 문법 범위1 클래스 - 생성자와 소멸자 (정의, 스택, 호출되는 순서)  , this 포인터의 이해 
// this 와 const 함수의 작동 원리 

#include <iostream>


class Player
{
public:
    // 생성자; 구조체 호출 시 자동으로 불려치는 함수 
    // 사용법: 구조체/클래스의 이름과 동일하게 쓰고 비워둠. 
      
    Player() // 목적; 구조체의 멤버변수 초기화 (방법: 2가지)  
        // 또는 2.멤버 이니셜 라이저 형태로 초기화 가능. 
        : x(0) , y(0), grade(0) // 이렇게 초기화 
    {
        // int x = 10; (1.이렇게 초기화 하거나) 
        // int y = 7; 
        // char grade = 'a';
    };

    // 소멸자: 해당 클래스를 만든 메모리 영역이 사라질때
    // (= 지역을 벗어났을때) 호출되는 함수 
    // 사용법: 생성자 이름 앞에 ~붙이기. 
    ~Player()
    {
    
    }

    // **this 의 개념**
    // 코드는 하나인데, warrior.x가 두 객체 중 첫번째의 멤버변수임을 알 수 있는 이유
    // 해당 클래스의 자료형에 this 포인터가 존재함. (주소가 넘어간다는 뜻. 생략되어있음) 

    void test(/*  Player* const this  */)
        //**this 포인터는, 포인터 변수(this) 뒤(?)에 const 가 붙어있는 형태임 ** = 바꿀 수 없는 주소값
        // const가 붙은 이유: 연산 처리 중 주소 값이 바뀌면 처리중이던 값이 워리어 1 에서 2 로 바뀔 수 있기 때문. 그리고 this에 저장해둔 값을 잃어버리게 되니까. 
    {
        this->x = 0; 
        y = 10;     
    }

    // this 포인터와 const 함수의 작동 원리 
    void test1(/*  Player* const this  */) const // 붙이면 멤버 변수 수정 불가. 떼면 수정 가능. 
        // ** 이해한 원리 원리
        // const this : this 에 들어오는 주소 수정 불가능
        // const Player* this : *this 의 값을 수정 불가능
        // const Player* this const : this 에 들어오는 주소 수정 불가능 & *this 값도 수정 불가능
            // ㄴ 라고 내부에 써줄 순 없으니, 보기 좋기 함수의 인자 뒤로 const Player*의 콘스트를 보내줌. 
    {
        this;
        x = 10;
        y = 10; 
    }

public: 
    // 이름: 멤버 변수 
    int x; // int x = 0;  이건 최신 문법. 씨샾에서 넘어옴 
    int y; // <- 이렇게 선언하고, 생성자에서 초기화하는게 C++ 스타일. 
    char grade; // 등급 
};


int main()
{
    Player warrior; // 객체라고도 부름. (object)
    Player warrior2;
    // 클래스 player의 warrior 가 만들어질때 
    // 생성자가 호출되면서 변수가 만들어지는 것을 알 수 있음 (위로 올라감) 

    // warrior 한개 만들었으므로, 소멸자도 한개가 호출됨. 
    // warrior 가 2개면, 소멸자도 두번 호출 됨. 

    // >> 생성자와 소멸자는 스택 <<
    // 생성자가 호출되는 순서: warrior -> warrior2
    // 소멸자가 호출되는 순서: warrior2 -> warrior

    // ** 메모리의 구조 **
    // 1. 코드 : 실제 작성한 코드가 이진파일로 업로드 
    // 2. 데이터 : 어디서든 접근 가능한 메모리, 전역변수
    // 3. 힙 : 내가 원할때 만들고 삭제 가능한 메모리.
    // 4. 스택 : 기본 세팅은 1MB. 
            // ㄴ 기본구조: 쌓이면서 생성, 마지막에 들어온 녀석이 먼저 나간다. 

    // **바이트 패딩**
    int len = sizeof(warrior);
    // int +int + char로 9바이트라고 생각할 수 있지만, 
    // 실제 warrior 메모리는 12 바이트가 할당된다.

    //바이트 패딩이 발생하는 이유
    //                <메모리>
    warrior.x = 10; /// ㅁ  (시작 주소)
                         //↓ 4byte 증가 (시작 주소를 넘겨줌) 
    warrior.y = 10; /// ㅁ
                         //↓1byte 증가 & 변경된 자료형의 자료.. 를 넘기는 걸 포기.  
    warrior.grade = 'a'; /// ㅁ // 4byte로 일괄 통일. = 메모리를 조금 더 쓰는 대신 연산속도를 높임
    // ㄴ char 
    // 보통 이런 주소값은 "캐시 메모리"에 저장됨.
    // ㄴ 여기에 전달되는 정보 값이 줄어듬로 연산이 늘어남. 
    
    // **바이트 패딩으로 메모리를 맞춰주는거
    // 자료형 제일 큰거 기준으로 할당.
    // double(8), int(4), int(4), char(1)
    // 8 + 8(int 2개) + 8(char) = 24 바이트 

    // ** const 의 개념 ** (this의 이해) 
    // 정의: 값을 바꿀 수 없게 고정해준다. 
    // 사용법: 변수 앞에 붙인다 or 포인터 변수(주소) 뒤에 붙여준다.
    // 주 사용처: 바뀌면 안되는 상수, 값, 주소 등에 사용한다. 
    int* const p = new int; 
    p = new int; // 식이 수정할 수 있는 값이 어야 합니다 : 수정 불가능하다는 뜻 

    const int g = 100; // g는 값을 바꿀 수 없음. 즉, 상수가 됨. 
    g = 10; // 바꿀 수 없게 오류가 발생한다.

    p = &g; // p에 콘스트가 걸려있으므로, 다른 주소값을 받아올 수 없게 된다. (수정이 안되므로) 


    // ** 포인터 변수 응용 : 반드시 암기 **
    
    // int* const p = new int; // == int 형 포인터 변수 p의 주소를 변경할 수 없다. (역참조 *p 변경은 가능) 
    // ㄴ int* (const p) 이렇게 감싼 느낌 (this 가 이거임) 
 
    // const int* p = new int; // == 역참조 연산(*p)할 때 값을 바꿀 수 없다 (p는 변경 가능: 다른 값을 가리킬 수 있음 ) 
    // ㄴ (const int*) p 이렇게 감싼 느낌 

    // const int* const p // == 주소(p)도 바뀌지 않고, 역참조 연산(*p)해서도 값을 바꿀 수 없음. 

    // int* p const <- 유효한 문법이 아니다. 

    return 0;
}

