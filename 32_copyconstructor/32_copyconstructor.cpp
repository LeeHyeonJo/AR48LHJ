// 32_copyconstructor.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
// 복사 생성자~ 

// ** 프로그램이 중단되는 경우 **
// 1. 같은 메모리 위치를 또 지우려고 할 때 
// 2. 포인터가 nullptr을 참조할 때 

#include <iostream>

struct player
{
    int hp;
    int mp;
    char* name; // 이름은 동적할당 할거라서 포인터 변수

    player()
        :hp(10)
        , mp(10)
        , name(nullptr)
    {
        // 기본 생성자 
    }

    ~player() // 소멸 생성자 
    {
        delete name; // 동적 할당한거라서 지워줌 ** 동적할당한 메모리를 지울때, 문제가 발생!! ** 
    }

    // 복사 생성자가 호출된다. 
    player(const player& other) //  = default 기본적으로 호출하는 생성자를 사용하겠다는 뜻. (하단 안 써도 됨) 
        : hp(10)
        , mp(10)
        , name(nullptr)
    {
        // **const player& other은 const player* other 와 동일함. 
        // 단, 포인터로 사용할 경우. 이 내부에서 *other / other-> 이렇게 접근해야 함
        // 하지만 레퍼런스로 선언하면 별도의 별, 화살표 표시 없이 

        // other이라고 사용해도, *other 과 용이하게 사용할 수 있다. 

        // ** 복사 시, 동적할당한 문자열이 delete 시 문제가 일어나지 않도록 **
        // ** 문자열만 새롭게 힙을 할당 후, 거기에 문자열을 넣어주고 ** 
        // ** 그 주소를 새로운 객체의 name에 받아주는 것이다 **

        // *** 내부 코드 복붙하기 ***
    }

};

int main()
{
    player pl1;
    pl1.name = new char[234];
    strcpy_s(pl1.name, 234, "이현조"); 

    // pl1의 값을 그대로 복사해서 pl2로 새롭게 만드는 경우
    player pl2(pl1);  

    // 다른 객체를 가지고 생성을 시도할 시 생성자 대신 복사생성자가 호출된다. 

    // ** 포인터의 단점 ** 
    // 역참조할때마다 별, 화살표등 써야하는게 많다. 
    // >> 이를 보완하기 위해 등장한 것이 바로 "참조"(레퍼런스) 

    // ** 레퍼런스 
    // 사용법: &을 붙인다.

    int num = 100; // 메모리에서의 상황: num [ 100 ]
    int& ref = num; // 메모리에서의 상황: ref/num [ 100 ] 포인터는 변수 하나를 더 만들어서 쓰는 개념. 

    ref = 200; //num까지 200으로 바뀐다. 

    // 포인터와의 차이를 잘 기억해두기 // 
}

