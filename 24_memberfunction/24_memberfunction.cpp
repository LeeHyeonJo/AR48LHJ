// 24_memberfunction.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
// 멤버 함수의 작동원리, 생성자, this 포인터의 개념 

#include <iostream>

struct player1
{
	int hp;

	player1(/*Player* this*/) // 생성자로 초기화가 가능한 이유: this 포인터로 들어오는 값을 받아주기 때문. 
		: hp(100) /*this->hp = 100; 인것. this는 p1,p2,p3...*/
	{
		// 생성자. hp를 멤버 이니셜라이저 방식으로 초기화. 
		// 생성자의 역할은 이렇게 구조체/클래스의 변수를 초기화할때 사용한다. 

		// this 포인터로 받은 주소의 값(ex. p1.hp, p2.hp)을 초기화해주는 원리이다. 
	}

	void damaged(/*Player* this*/) // 이게 멤버함수. 
	{
		/*this->*/hp -= 10;
		/*this->hp -=10; 인것. this는 p1,p2,p3...*/
	}
	// 해설: 플레이어1이라는 구조체의 객체를 생성하면, 객체들의 기본 hp는 100. 
	// 그리고 hp를 -10 감소하는 "행동"(함수)를 갖고 있게 된다. 
};

// **멤버 함수 등장 이전의 방법
// 1. 이렇게 전역에 damaged 함수를 만들어준다.
// 3. 입력받은 player의 hp를 감소한다. 
void damaged(player1* player)
{
	player->hp -= 10; 
	// _this->hp -= 10;
	// this란? () 안에 들어오는 데이터를 "통틀어서" 지칭하는 것.
	// 멤버 함수 작동 원리의 핵심 (= 함수 하나를 만들어서 쭉 쓰겠다는 것) 

	// 기본 방식은 들어오는 값이 player, monster, npc.. 이렇게 다 다르게 쓰고 각 함수를 지정해서 썼는데
	// this 포인터 (= 들어오는 값) 를 사용함으로서, 함수 1개로 여러 객체의 값을 받아서 사용할 수 있게 된다.
	// 다용도 그릇이라고 생각하면 된다. 
}

int main()
{
	// 객체 선언
	player1 p1;

	// 2. 전역함수로 p1의 값을 보낸다. 
	damaged(&p1);

	// **옛 방식(C스타일)의 단점 : 객체가 늘어나면 함수를 계속 추가해야 함//
	// 이유: C 스타일에선 멤버함수가 없었고, 새로운 객체의 값을 바꿔주려고 할 때마다
	// damaged(&p1) damaged(&p2)damaged(&p3) 전부 호출해줘야했음.

	// >>>>>>>> 이것을 보안하기 위해 C++에서 등장한 문법이 "멤버 함수" 
	// 사용법: 구조체 내부에서 함수를 선언 후 사용한다. 
	// ㄴ 전역이 아니라, player라는 구조체, monster라는 구조체 자체가 함수(행동)을 들고 있도록 설계함. 

	//**멤버함수의 원리: this 함수 
	// C++에선 이걸 .. 함수를 하나만 쓰고 싶었음. 그래서 전역변수로 쓰던 함수를 구조체에 넣어주고.
	// 구조체로 들어간 함수(멤버함수) 가 인자(p1,p2,p3)를 받을때, 
	// archer.player 이렇게만 작성해도. archer을 넘겨도, 자동으로 생성된 this에 archer의 주소가 들어가게해줌.
	// >> 멤버함수 하나로, this 포인터 변수 덕분에 들어오는 모든 인자들 각자에 접근할 수 있게 된거임. 
	// 쓰다보니 이해한듯. 
}


// ** 객체지향적 프로그래밍 **
// 정의:함수 먼저(동작 먼저). 그 다음에 변수 작성하기. 
// 예시: 몬스터와 플레이어가 서로를 공격하고 대미지를 입는 프로그램 구현하기. 

class player // 기본이 private
{
	// 1. 플레이어의 동작(함수)를 구현한다.
	// 파이어볼을 발사할 수 있다. 
	void fireball(monster* monster)
	{
		// pl1.pl2,pl3 전부 이 함수를 사용할 수 있음. 
	}

	// 달릴 수 있다.
	void run(monster* monster)
	{

	}

	// 2. 1의 함수에 필요한 변수들을 작성한다. 

	int speed;
	int mp;
};


struct monster // 기본이 public
{
	// 1. 몬스터가 플레이어의 공격을 받는다 
	void damaged(player* player)
	{

	}

	// 2. 몬스터가 플레이어를 공격
	void damaged(player* player)
	{

	}

	// 3. 1,2 번 함수에 필요한 변수 작성

	int att;
	int hp;
};

