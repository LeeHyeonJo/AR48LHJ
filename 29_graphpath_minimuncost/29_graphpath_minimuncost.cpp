// 29_graphpath_minimuncost.cpp
// ** 그래프로 경로찾기의 응용 **
// 가장 "빠른" or "저렴한" 경로 찾기 (dfs)

#include <iostream>
using namespace std; 

int map[7][7] =
{
 // 5,1,35,1,10,70,20
    0,1,1,0,0,0,0, //5
    0,0,0,1,0,1,0, //1
    0,0,0,0,1,1,0, //35
    0,0,0,0,1,0,0, //1
    0,0,0,0,0,0,1, //10
    0,0,0,0,0,0,1, //70
    0,0,0,0,0,0,0, //20

}; // 0. 그래프 그려보고 시작하기. (함)

// 문제: 5에서 출발해서 20으로 가는 최단 경로의 합 

int number[7] = { 5,1,35,1,10,70,20 };
// 연결된 녀석들 

//** 1. 가장 빠른 경로를 찾아보자
int visited[7] = {}; // 중복 방문 방지용
int min1 = 98765454; // 최소 찾기용 

void dfs(int now, int sum)
// sum 은 5(0)->20(6)까지 가면서 
// (도착점) 에 도달했을때 지나온 모든 노드들의 경로의 합. 

{
    // 2. (최소값 구하기) 도착했을때의 조건 작성해줌 
    if (now == 6)
    {
        if (min1 > sum)
        {
            min1 = sum;  //min1 에 sum값이 들어감 
        }

        return; 
    }

    // 1. 인접행렬돌면서, 경로에 기록해주고 & 경로를 더해나가는 행위 
    for (int x = 0; x < 7; x++)
    {
        // a. 인접행렬이 0이면 컨티뉴
        if (map[now][x] == 0)
        {
            continue; 
        }

        // b. 비지티드가 1이면 (한번 방문했던곳이면) 컨티뉴 
        if (visited[x] == 1)
        {
            continue; 
        }

        visited[x] = 1;
        dfs(x, sum + number[x]);
        visited[x] = 0; 
    }

}

int main()
{
   // 처음 시작할때 비지티드 반드시 체크 // 
   // 5에서 시작 (number[0] = 5) 
    visited[0] = 1; 
    dfs(0, number[0]);  // now(y축),sum(경로의 합 저장) 
    cout << min1; 
}


