// 18_DirectAddressTable.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
// 해시 테이블 : 간단한 예시. 원리만 이해하기. 실제 해시 알고리즘은 더욱 복잡함.        

#include <iostream>

// 해시 함수 (~이렇게 활용할 수도 있따. 정도.) 
int hashFucntion(int data) // 반환된 값이 배열의 index. 
{
    int index = 0;

    index = data * 7 / 32 + 22 - 108 * 32; // 이거 아마 들어온 값에 어떻게 해서 아스키값 뽑은거인듯. 
    return index;

    //** 해시 테이블의 단점 
    // 중복값이 나올수있다. (= 동일한 인덱스가 나오는 경우) 
    // 해결법: 없음~ 
}

//STL에도 해시함수를 이용해서 작성하는 것이 있다. 

int main()
{
    // ****각 글자가 몇개가 있는지 세는 방법. 
   // A=5, B=n..을 아래 배열의 인덱스에 값으로 넣어주는 원리. 
   
    char str[256] = "ASDVVSDFEBDSSFAJEJFKDKEJZ";

    char target = 'A'; // A의 아스키 값
    //1. A가 나올떄마다 A의 갯수를 세어준다. 

    int bucket[128] = {}; // bucket 이라는 배열 선언. 크기는 넉넉하게. 
    for (size_t i = 0; i < 256; i++) // 256 만큼 딱 한번만 돌면서,
    {
        char target = str[i]; //target에 str[i] 에 해당하는 문자를 받아준다. 
        bucket[target]++; // target = 에 들어있는 문자의 아스키코드를 "인덱스" 로 사용한다. 

        // = 실행시, A~Z까지의 아스키값에 해당하는 bucket의 인덱스에
        // 해당 인덱스에 A~Z까지의 개수가 누적된다.
    }


    // ** 특정 알파벳의 갯수 불러오기
    int len = bucket['B'];
    // B의 아스키값을 (위에서 정리해줬으니까) 
    // bucket 배열의 인덱스로 사용. 불러오기
    

    // for문으로 하면 배열의 크기 (256)x알파벳 개수만큼 돌아야해서 비효율적.
    // 이것이 "해시 테이블" 의 기본 원리 
    // : 엄청 큰 배열에 고유의 인덱스를 만들기. 그 인덱스에 대응하는 데이터를 저장하는 것. 
    // : 아스키 코드를 인덱스로 사용하거나, 위의 예시처럼 함수를 만들어서 사용할 수도 있다. 


    // **** 해시 테이블의 응용 ***** >> 데이터를 저장하거나, 정렬하는 것도 가능하다. 
    // 복습: 이거 원리 복습하기
    // 요약: 데이터 정렬시 선택지가 늘어남. 1. 선택 정렬 2. 해시 테이블(배열의 크기가 크면 이쪽 추천) 
    // (전제; bucket에, arr 배열에 있는 알파벳의 갯수를 세어서 저장해둠) 
    for (size_t i = 1; i < 128; i++) // 1. bucket의 크기만큼 for문을 돈다
              // ㄴ 1인 이유 (0으로 하면 0의 값의 배열까지 다 세어버림) 
    {
        if (bucket[i] > 0) // 2.해당 인덱스에 값이 있다면 = arr 배열에 그 알파벳이 존재할 경우 (데이터의 값이 존재)
        {
            for (size_t j = 0; j < bucket[i]; j++) // 3. 그 값만큼 반복 ( = 인덱스의 알파벳이 존재하는 개수만큼 반복) 
            {
                std::cout << (char)i; // 인덱스를 char로 형 변환.  (= 해당 알파벳을 char형으로 출력)
                // 목적: bucket에 arr배열의 알파벳의 개수를 해시테이블로 정렬
                // ㄴ 알파벳의 아스키값을 인덱스로 사용해서 넣어줌.
                // ㄴ 그리고 갯수가 존재하는 = arr배열에 존재하는 알파벳인 경우
                // 그 갯수만큼 해당 알파벳을 출력해줌

                // 즉. 갯수만을 정리한 배열을 인덱스를 활용해서 원래 데이터를 뽑아낸 것. 
                // 결과: A~Z까지 작은 알파벳부터 큰 알파벳까지 정렬해서 출력함. 
                // 아스키 코드를 인덱스로 정리할 경우 가능한 것. 
            }
        }
    }

    return 0;
}

