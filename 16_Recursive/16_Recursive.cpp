// 16_Recursive.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
// 재귀함수 : 종료조건을 잊지 말자.
// 복습; 재귀함수 문제풀이 파란 노트에 푼 거 그림 꼭 참고하기 
#include <iostream>

// 0525 
// 재귀함수를 중첩할 때!! 
// 함수가 어떻게 작동되는지 그림 파악하기. >> 함~

//0526: 재귀함수 위치 헷갈리지? 배열에 기록할 수 있어.
char path[8] = {}; // 여기에 기록할거임. 왼쯕으로 갈때는 a,오른쪽일때는 b


void kfc(int level)
{

	if (level == 5) // 뽑을 카드의 숫자. (ex. 총 5장체서 ) 
	{
		return;
	}

	// 이하를 이렇게 포문으로 묶어줄 수 있따. 

	for (int i = 0; i < 2; i++) // i개만큼 뽑으아 만들수 있은 모든 경우의 수(ex.2장을 봅아 만드는 경우의 수) 
	{
		path[level] = 'A' + i;
		kfc(level + 1);
		path[level] = 0; 
 	}
	// 숙제: path 꼭 확인하면서 파악하기. (22레벨 문제) 
	// 들어가기 전에 경로를 기록하고, 나올때 지우는 것이다. 
	// >> 모든 경우의 수 문제는 "재귀 함수" 로 푼다. 
	// 문제를 볼때, 무엇이 branch이고 level 인지 잘 읽어야 함. 

	path[level] = 'a';
	kfc(level + 1);
	path[level] = 0; // 리턴할 때, 지워줌 

	path[level] = 'b';
	kfc(level + 1);
	path[level] = 0; // 리턴할 때, 지워줌 
}

void bbc(int level)
{	
	if(level == 3)
	{
		return;
	}
	bbc(level +1); 
	std::cout << level; 
}	

// 복습: 재귀함수의 작동 원리 그림으로 꼭 그려가면서 풀기 
//  ㄴ 호출스택을 보아도 됨. 
// bbc(0), bbc(1)... 은 전부 다른 함수, 같은 코드를 재활용했을 뿐
// 동일한 동작을 여러번 수행할 때, 같은 코드 매번 치기 힘드니까, 이럴때 쓰는 함수인 것. 
// ** 코드만 나눠쓰되, 전부 다른 함수라는 것을 알아야 함 ** (같은 함수로 반복x) 

int main()
{
	bbc(0);

	// 개념: 자기자신(함수)를 호출하는 함수. 일반적인 함수를 호출하는 것과 동일한 매커니즘. 
	// 특징; 잘못 사용시 스택이 넘쳐서 강종됨. 
	// 주된 사용처: 자료구조 - 그래프(ex. 게임 맵 얽힌거), 트리 순회할 때 필수로 사용 
	//				ㄴ (배열 순회,list -> 반복문 사용)
	// 장점: 1. 가독성(소스코드가 간결해짐) , 2. 경우의 수 문제에 편리(but 느릴 수 있음; 모든 경우의 수를 다 비교)
	// 필수: 종료조건이 있어야 한다. 없을 시 -> "스택 오버 플로우" 현상이 발생.
	// ㄴ 스택오버플로우: 스택의 메모리가 꽉 차서 더 이상 기억 불가능한 상황. 스택에서 함수를 계속 호출하다가
	// ㄴ 그것이 스택의 범위를 넘을만큼 호출된 후 멈춰버리는 현상. 
	
	// 재귀함수의 예시: 상단의 bbc 함수 참고 
	// ㄴ 종료조건(level) 없이 실행먼저 해봄. : bbc(); 함수로만 작성 
	// ㄴ그 후 종료조건 추가해서 재귀함수의 작동원리를 눈으로 확인함. 


	return 0; // return =  종료보다는, 이 함수를 호출한 곳으로 돌아간다(return)는 뜻. 
}

/////////// 재귀함수 간단한 문제 풀이 /////////////

// 도전 재귀함수 (내 풀이) 
// 포인트: 종료조건, return을 만났을때 어디로 돌아가는지.
// return을 만났을때, 이전 코드는 어떻게 되는지. 그리고 어느 코드로 돌아가서
// 어디까지 실행하는지. 반드시 그림으로 그리고 눈으로 코드를 확인할 것. 

#include <iostream>

void arrprint(int level, int Arr[5])
{
	for (int i = 0; i < 5; i++)
	{
		std::cout << Arr[i];
	}
	// 일단, 배열을 출력하게 한다.

	if (level == 0) // 종료조건을 설정한다. 
	{
		return; // 충족하므로 arrprint0을 호출한 main으로 돌아간다. 
	}

	/*for (int i = 4; i >= 0; i--)
	{
		std::cout << Arr[i];
	}
	여기에서 역방향 출력인가?
	아님! return을 만나서 돌아갈때, 그 밑에있는 건 전부 실행되지 않음.*/

	// 종료조건이 1이라면,
	// if에서 level 체크 후, 여전히 level == 0일떄.
	// if문이 거짓임을 확인한 후, 그 밑에 있는 코드 ( = arrprint 0 의 영역)이 실행된다ㅑ.
	// 어디부터 어디까지가 종료조건에 맞는 함수의 영역인지 잘 확인할것. 
}

int main()
{
	int arr[5] = { 5,7,1,2,3 };
	// 정방향으로 출력 후, 역방향으로 출력
	// 재귀함수를 활용할 것.

	// 일단 정방향으로 출력하는 함수를 작성한다.

	arrprint(0, arr);
	// arrprint 0에서 빠져나와 main으로 돌아옴.
	// 마저 이 밑의 코드 (main의 것)을 실행한다.

	for (int i = 4; i >= 0; i--)
	{
		std::cout << arr[i];
	}
}

//// 선생님 풀이
// 포인트: 종료조건을 index로 활용할 수 있다. 

// 재귀함수 모법담안
#include <iostream>

int arr[5] = { 5,7,1,2,3 };

void wow(int level)
{
	if (level == 5)
	{
		return;
	}
	std::cout << arr[level];
	wow(level + 1);
	// return 받고 돌아오는 곳 
	std::cout << arr[level];
}

int main()
{
	wow(0);
	std::cout << "재귀함수가 종료되었습니다.";
}