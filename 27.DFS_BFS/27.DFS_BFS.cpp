// 27.DFS_BFS.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
// 
// 오늘은 그래프의 DFS/BFS: 한번 갔던 곳을 다시 한 감. used로 체크
// 트리의 DFS/BFS: return 해가며 돌아옴. 
// 
// 1. 특정 노드에 도착하는 경우를 찾아보자.  & (아래는 응용) -> flag 활용 
// 2. 특정 노드에 갈 수 있는지, 아닌지를 체크해보자 -> flag 의 0,1 체크. 

// 3. 모든 경로를 출력해보자 :: path  배열을 만들어서 [level] , 배열[i]을 기록. 
    // 응용: 마지막 도착지가 특정 문자 -> path를 활용해서 가지치기 

// 배우는 이유: 프림 알고리즘, 다익스트라 알고리즘. 

// 1. 순서: 그래프를 그리고, 시작할 노드를 정하고 Z(0번 노드) -> B(5번 노드)로 향하는 법 
// 2. 순서: 그래프를 그리고, 시작할 노드를 정하고 (0번) -> (4번) 으로 갈 수 있는지, 아닌지 체크해보기. 

// f5와 f9(중단점) 사용 가능. 

/// ** 예시로 보여준 건 ((모든 경로를 출력)) 하는 코드 ** DFS///

#include <iostream>

int visited[10] = {}; 

int matrix[6][6] = 
{
    0,1,1,1,0,0,
    1,0,0,1,0,1,
    1,0,0,1,0,0,
    1,1,1,0,1,1,
    0,0,0,1,0,1,
    0,1,0,1,1,0,
};

char value[10] = "ZADCEB"; 
int flag = 0; // 목표로 했던 노드에 도착할 경우, 체크해주는 변수. 

void dfs()
{
    // 경로를 찾을 땐 

    if (now == 5) // 5는 도착할 노드: 그래프의 예시에선 5번 노드의 B
    {
        flag++; // -> 응용: flag의 0,1 유무로 연결 여부도 체크할 수 있음. 
        return; 
    }

    // 기억할거 2: visited 들어갈때 체크 후, 리턴되어 날올때 지워줘야 함
    // 이유: ZAB -> ZACEB 등 이렇게 원래 갔던 경로를 다시 체크해야하 할 필요도 있기 때문. 

}


int main()
{
    // 기억할 거1: 처음 들어갈때 체크! 
    visited[0] = 1; 
    dfs(); 
}


// BFS 코드는 이쪽에. 큐 활용. 앞에 공부하고 넘어오기. 



// 이진트리를 1차원 배열에 옮겨서 학습하는 방법. 

int used[234] = {}; 

char binarytree[342] = "_ABCDE";
void dfs(int level)
{
    if (binarytree[level] == '\0')
    {
        return;
    }

    dfs(level * 2);
    dfs(level * 2 + 1);

}