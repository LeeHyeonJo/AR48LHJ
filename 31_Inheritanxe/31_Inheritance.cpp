// 31_Inheritance.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
// 클래스의 "상속" : 자식클래스가 부모클래스의 멤버 변수와 멤버 함수를 물려받는 것. 
// ㄴ 대부분의 클래스에 중복되는 코드를 부모 클래스에 넣어주고, 그걸 자식 클래스에 상속하는 방식으로
// ㄴ 코드를 조금 덜 치고, 가독성을 높혀주기 위한 문법. 

#include <iostream>
using namespace std; 

class gameobject // 부모 클래스 
{
public:
	int x; // 위치정보
	int y; // 위치정보 : 계속 반복되어서 게임 오브젝트 클래스에 몰아줌. 

	// ** 이 위치정보, x & y를 다른 클래스에 "상속" 해준다!! ** // 
};

// 문법: 상속해줄 클래스의 옆에 : public(우선은 퍼블릭 상속만) 상속할 부모 클래스 이름 
// 기능: 부모 클래스에 들어있는 내용이 자식 클래스에게 상속된다. 

class player : public gameobject 
{
public:
	// int x; 게임 오브젝트로 이동한 코드. 
	// int y; 몬스터, npc도 동일하게 적용했다. 

	int hp; 
	int mp; 

	void speak()
	{
		cout << "안녕"; 
	}
};

class monster : public gameobject
{
public:
	int hp;
	// 마법은 못 씀 

	void speak()
	{
		cout << "으르릉";
	}
};

// npc를 만들거임
class npc : public gameobject
{
public:

	// 죽으면 안되니까 hp,mp등은 빼줌 

	void speak()
	{
		cout << "필요한 물건은 없니?";
	}
};

// ... 이렇게 캐들을 하나하나 만들다보면 중복되는 코드가 있음.
// 위의 경우, 위치 코드가 계속 반복되고 있음.
// 이걸 매번 다 넣어주는것이 불편하다. 
// ㄴ 캐릭터의 정보를 모두 갖고 있는 클래스를 만들자.
// 


int main()
{
	player hero;  
	monster pig;  
	npc mom;  

	// 상속을 받은 받은 자식클래스는, 부모 포인터의 클래스 변수에도 자식 클래스를 담을 수 있다 ** // 
	// ㄴㄴ 단! 값은 잘려서 나온다. (주소 보관만 가능함) 
	// !!: hero의 자료형은 player. 근데 hero 의 주소를 gameobject형의 포인터 변수 (arr)에 저장하고 있다.
	// !!: 이 경우, 값이 잘려서 나온다. (게임 오브젝트는 8바이트, 플레이어는 16 바이트) 
	// arr[0]. // 이렇게 할 시, x와 y 총 8바이트의 값만 불러오는 것을 확인할 수 있다. 

	gameobject* arr[3] = { &hero, &pig, &mom }; 
	// 하고 싶은거: for문으로 돌면서, 각 캐릭터들의 대사를 출력하고 싶음
	// 부모 함수에 speak 대사를 넣으면, 같은 대사만을 반복하게 된다.
	/// ㄴ	// 각 클래스별로 다른 대사를 출력해보고 싶다.

	// ** 이 문제를 해결하기 위해 등장한 것: 가상함수!! 

	for (int i = 0; i < 3; i++)
	{
		arr[i]-> // speak 라는 함수가 출력되지 않음. 
	}
	
	// 0616 1시간 부터 듣기 
}

