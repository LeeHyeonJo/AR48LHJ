// 20_dynamic.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
// 동적 할당 (클래스보다 먼저 함) new - delete
// 동적 할당을 알려면, 정적 할당을 먼저 알아야 한다.

    //기본 원리: 힙에 10개x자료형만큼 할당 후. 그 첫 주소값(포인터)를 불러온다
    // 그렇게 해야 힙에 접근해서 사용할 수 있음.

// 선 요약; C언어에서는 malloc() - free()로 사용하던 동적 메모리의 할당.
// C++에선 new와 delete로 사용한다. malloc()은 메모리 크기를 내가 정해줘야 하지만 new는
// 그러지 않아도 된다. 

#include <iostream>

int main()
{
    // **정적 할당 (ex. 지역변수) 

    char arr[4][256] = {};
    // 프로그램을 실행시 크기가 이미 정해져있음. 
    // ㄴ 256바이트. 그리고 절대 바뀌지 않음. 
    // 단점; 메모리 낭비가 크다. 


    //**동적 할당
    //프로그래머가 원할 때 크기를 정해서 메모리에 할당하는 것. 
    int num = 10;

    // 메모리를 동적할당 해준다면, 배열도 동적할당할 수 있게 된다. 
    // ** 사용법 (C언어에서의 사용법부터 시작한다.) 

    malloc(num); 
    // 원리: malloc 함수의 기본 반환형은 void*.
    // 이때 num은 힙에 할당할 메모리의 크기를 의미함(바이트) 
    // 힙에 할당된 메모리의 주소를 반환해주기 때문. (주소만 반환할때는 보이드 자료형)

    // 하고싶은것: 힙 영역에 메모리 할당, 그리고 그 첫 주소 받기 

    void* p = malloc(num);

    *p; // 이렇게 역참조해서 사용 불가능 (void형태)이므로 

    //++만들고 싶은거: int형태의 배열을 동적 할당 

    // 1. 소괄호에 들어있는 정수 바이트만큼 할당됨 
    int* dynamicArr = malloc(num);

    // 2. 근데 이제 인트형임. 그럼 int(4바이트) 곱하기 10이 됨 
    int* dynamicArr = malloc(sizeof(int)*num); 

    // 3. malloc은 기본 void 형태이므로 강제로 형변환 -인트 포인터 형을 해야 함
    int* dynamicArr = (int*)malloc(sizeof(int) * num);

    // **동적 할당한 dynamicArr 배열. 힙에 위치함
    // int형으로 num(10)개 할당해둠.
    // 즉, 10개의 힙 칸을 사용하고 있음
    // for문을 돌려서 각 힙 칸에 접근함. (배열이니까!!) 
    for (int i = 0; i < 10; i++)
    {
        dynamicArr[i] = i + 1;
        std::cout << dynamicArr[i]; // 동적할당한 힙이 10개임을 확인.i출력함. 딱 확인 용도. 
    }

    /// 동적 할당은 프로그램이 종료될때까지 남아있다. 
    // 아래처럼 해제하면 됨. : 근데 해제할때는 자료형 선언 없이도, 어떻게 정확히 바이트를 해제해준거지?
    // 주소값만으로 메모리를 해제해준 상황임. 

    //*펜스 메모리(4바이트) fd fd fd fd //// fd fd fd fd
    // 덮개처럼 내가 선언한 메모리 양 옆에 붙어있음. 
    // 해제할때 가운데에 있는 //// 만 지우게 됨. 
    // 그래서 진짜진짜 이론적으론 메모리에선 내가 선언한 메모리 + 펜스 메모리(4바이트 + 4바이트) 만큼 할당됨. 
    // **그래서 자료형 없이도 delete로 해제가 가능했다. 

    delete dynamicArr;  
    // 동적할당의 단점
    // 메모리를 직접 원하는 크기만큰 할당했죠?
    // 그러면 메모리를 프로그램이 종료되기전에 
    // 수동으로 직접 해제 해줘야한다.

    // 해제 해주지 않으면 memory leak 이 발생한다.


    // *** C++에서 이거 너무 힘들어서 새로운 문법을 만듦
    // 바로바로 ~~~ new (delete로 해제) 
    // <사용법> 
    //1. 메모리 할당: 자료형* 변수 이름 = new 자료형; 
                       int* heaptest = new int; 
    //2. 메모리 할당 해제: delete 변수 이름 
                       delete heaptest; 
    

    //** 배열 형태로 동적할당도 가능하다!
    // 주의점: 배열 형태로 할당한 것은, 메모리 해제도 배열 형태로 해주어야 한다. 
    // <사용법> 
    // 1. 메모리 할당(배열): 자료형* 변수이름 = new 자료형[배열크기];
                             int* heaptestarry = new int[5];
    // 2. 메모리 할당해제(배열): delete[배열크기] 변수 이름
                                 delete[5] heaptestarry; 


     // 복습: 힙에 메모리 동적 할당 > n개만큼 할당 후 출력해보기 > 해제해주기
     // 참고: https://coding-factory.tistory.com/480

}

