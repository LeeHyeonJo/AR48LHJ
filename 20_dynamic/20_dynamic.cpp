// 20_dynamic.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
// 동적 할당 (클래스보다 먼저 함) 
// 동적 할당을 알려면, 정적 할당을 먼저 알아야 한다.

    //기본 원리: 힙에 10개x자료형만큼 할당 후. 그 첫 주소값(포인터)를 불러온다
    // 그렇게 해야 힙에 접근해서 사용할 수 있음.

#include <iostream>

int main()
{
    // **정적 할당 (ex. 지역변수) 

    char arr[4][256] = {};
    // 프로그램을 실행시 크기가 이미 정해져있음. 
    // ㄴ 256바이트. 그리고 절대 바뀌지 않음. 
    // 단점; 메모리 낭비가 크다. 


    //**동적 할당
    //프로그래머가 원할 때 크기를 정해서 메모리에 할당하는 것. 
    int num = 10;

    // 메모리를 동적할당 해준다면, 배열도 동적할당할 수 있게 된다. 
    // ** 사용법

    malloc(num);
    // 원리: 반환값을 보면 void*.
    // 이때 num은 힙에 할당할 메모리의 크기를 의미함(바이트) 
    // 힙에 할당된 메모리의 주소를 반환해주기 때문. (주소만 반환할때는 보이드 자료형)

    // 하고싶은것: 힙 영역에 메모리 할당, 그리고 그 첫 주소 받기 

    void* p = malloc(num);

    *p; // 이렇게 사용 불가능 (void형태)이므로 

    //++만들고 싶은거 int형태의 배열을 동적 할당 

    // 소괄호에 들어있는 정수 바이트만큼 할당됨 
    int* dynamicArr = malloc(num);

    // 근데 이제 인트형임. 그럼 int(4바이트) 곱하기 10이 됨 
    int* dynamicArr = malloc(sizeof(int)*num); 

    // malloc은 기본 void 형태이므로 강제로 형변환 -인트 포인터 형을 해야 함
    int* dynamicArr = (int*)malloc(sizeof(int) * num);

    // 이거 뭐지? 
    for (int i = 0; i < 10; i++)
    {
        dynamicArr[i] = i + 1;
        std::cout << dynamicArr[i]; 
    }

    /// 동적 할당은 프로그램이 종료될때까지 남아있다. 
    // 아래처럼 해제하면 됨. : 근데 해제할때는 자료형 선언 없이도, 어떻게 정확히 바이트를 해제해준거지?
    // 주소값만으로 메모리를 해제해준 상황임. 

    //*펜스 메모리(4바이트) fd fd fd fd //// fd fd fd fd
    // 덮개처럼 내가 선언한 메모리 양 옆에 붙어있음. 
    // 해제할때 가운데에 있는 //// 만 지우게 됨. 
    // 그래서 진짜진짜 이론적으론 메모리에선 내가 선언한 메모리 + 펜스 메모리(4바이트 + 4바이트) 만큼 할당됨. 
    // **그래서 자료형 없이도 delete로 해제가 가능했다. 

    delete dynamicArr;  

    new 
    /// 0000000c C++에서 이거 너무 힘들어서 새로운 문법을 만듦


}

