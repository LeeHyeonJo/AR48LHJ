// 12_pointer.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
// 포인터!! : 시작값을 알면 모든걸 알 수 있다. 
// 활용해서 여러 값을 return 할 수 있다. 

#include <iostream>
// *포인터로 여러 값을reurn 받아보자.
// 함수의 인자로 포인터 값(주소)를 받는 것도 가능하다.


void test(int* a, int* b) // int형 포인터 변수 (int 메모리의 주소값을 받는 포인터 변수)
// 메모리의 주소는 16진수의 정수임 항상! int인건 저장한 메모리의 자료형이 int라서! 
{
    *a += 1; // 불러온 주소값a에 *을 찍음  = a 값 자체(원본)에 +1한다. 
    *b += 1; // 불러온 주소값b에 *을 찍음 = b 값 자체(원본) 에 +1 한다. 
}

// 인자로 전달된 값은 "원본"의 주소이다.
// *원본주소 로 접근 후, 원본의 값을 수정하기 때문에
// 결론적으로는 여러 값을 return 하는 효과를 볼 수 있다!!


void test(int arr[2][3]) // 1.이차원 배열은 인자로 넘길땐 이렇게 넣는게 가장 베이직. 
{
    arr[0][0] = 1;
} 

//이차원 배열을 포인터 변수로 다루는 법은 조금 다르다. 
//배열 포인터 :: 2. 이차원 배열 인자로 넘겨주는 정석. (근데 1번 더 자주쓴다) 

void test(int(*pointer)[3])

//숙제: 돌아가는 방식 그림 그리기 
// [int a][int b][int c] = 12byte
// int(*pointer)[3] >> int형 3개 한 줄의 주소를 들고 있음.
// *pointer+1 하면 12바이트만큼 증가. 
// ㅁㅁㅁ
// ㅁㅁㅁ <= 여기에 접근. 

// ** 배열 포인터를 사용할 때 주의할 점 **
// 호환성! 
    // <-> 일차원&이차원 배열을 함수로 넘겨주기 
         // 1. 일차원  &arr[0] = 자료형* 타입의 포인터 / arr 배열 형식 
         // 2. 이차원  &arr[0] = 자료형* 타입의 포인터 / arr 배열 형식 
    // <-> 일차원&이차원 배열을 받아줄때 
        // 1. 일차원 (int* Arr : int* 타입) or (int Arr[3] : 배열형식)
        // 2. 이차원 (int(*pointer)[3] : int* 타입) / (int Arr[3][3] : 배열 형식)

// **함수 인자의 호환성** (1은 1로, 2는 2로 받아주어야 한다) 
// <main->함수로 전달>
// 1. &arr[0] or &arr[0][0] = 선언한 배열의 자료형* 타입(ex int* 타입) (주소를 저장하는 포인터) 
// 2. arr = 배열 형식 
// 
// <함수에서 받음> 
// 1. 자료형(*pointer)[x축] = x축 한 줄을 가리키는 포인터. pointer가 이동하면서 그 아래 줄에 접근하는 식으로
// ㄴpointer가 이동하면서 그 아래 줄에 접근하는 식으로 이차원 배열의 각 행에 접근할 수 있다. 
// 2. Arr[3] or Arr[3][3]: 배열 형식 

// ** int (*pointer)[3]에서 [3]은 배열의 x축(가로)을 의미.
// => 크기가 3인 int 포인터 배열
// 3개의 int 값으로 이루어진 1차원 배열 (가로 한 행) 을 나타냄
// >>> 주소를 저장하는 포인터, 각 포인터가 가리키는 배열은 하나의 가로줄
// >>> pointer를 이용해 2차원 배열의 각 행에 접근할 수 있다. 

{
    pointer[1][2] = 99; 
}

int main()
{
    int Arr[2][3] = {};
    test(Arr); 

    int num = 0; // 정수를 저장할떈 int
    char ch = '\0'; // 문자를 저장할땐 char

    char* pCh = &ch;
    *pCh = 'B';
    //*을 찍으면 해당 주소가 있는 메모리의 값을 불러온다. 


    std::cout << pCh; // 주소출력 
    std::cout << *pCh; // pCh의 값 출력 

    int arrnum[3] = {}; // 정수형을 여러개
    char arrchar[3] = {}; // 문자형을 여러개

    // 메모리의 "주소값"을 저장하고싶을때는 포인터 타입을 사용한다.
    // 사용법: 아래와 같다. 
    // void* p; 

    // p에 int num = 0; 변수의 주소값을 넣고 싶다. 
    // 대입하려는 값 앞에 &를 붙인다. 
    
    // void* p = &num;
    // >> void형은 오직 "주소형" 만 저장할때 사용한다. *역참조 안할때 
    int* p = &num; 
    // num의 주소: 0x0000009e1ad3f4f4
    // 16진수로 표현한다. (주소라는 걸 쉽게 알아보라고 약속함) 
    // ㄴ 정수임. 따라서 포인트 변수는 4바이트 크기임. (32비트 운영체제 기준) / 64비트 운영체제 기준으로는 8바이트. 
    // 메모리의 주소가 +1 증가할때, 실제 메모리 수는 포인트 변수의 자료형 크기만큼 증가한다.
    // int형 포인터 메모리였다면, 포인터 주소가 1 증가할때, 메모리는 실제로 4만큼 증가한다. 


    //1. 포인터의 기능 : 역참조 연산 
    // ㄴ일반 변수와는 다른 특별한 기능. 

    //1-1. 사용법. 
    // 주의사항: 불러오려는 변수(int num = 0;) 와 동일한 자료형으로맞춰야 한다. 
    // 그 바이트 값 만큼만 불러오기 때문임. 
    *p = 100; // 0이였던 num에 100을 넣은것. 

    //2. 포인터 변수를 함수로 활용해보자. 
    int d = 0; 
    int e = 0; 
    test(&d, &e); // test 함수로 d와 e의 주소를 보낸다. 
    // 즉, test 함수는 받은 인자를 단순 복사하는게 아니라( = 새로운 메모리 생성 후 만들기)
    // 원본 d,e에 접근해서 이를 수정할 수 있게 된다. 
        // > 이 원리를 이용해서 return 값을 여러개 받을 수 있다. (위에 설명) 

    //3. 배열 포인터
    // 배열을 함수로 넘겨줄때 사용한다. 
   
    // <-------main 에서 ---------->
    // test(arrA,arrB) 
    // 설명: test 함수로 배열 A와 B를 전달한다.
    // 이때, test 함수로 전달되는건 무엇일까?
    //  - 변수는 값의 복사, 포인터변수는 값의 주소(원본에접근)
    // 해답: 배열은, 대입할 경우 해당 인덱스의 가장 "첫번쨰 주소값([0]의 주소)"가 넘어간다. 
    // 그 후 주소에 +1 해가며 그 다음 인덱스까지 접근하는 것이다. 
    
    //엄밀하게, 주소를 넘기는 기호는 '&'이다.
    // 정석: test(&arrA[0],&arrB[0])
    
    //**동일한 선언법: 그러나 너무 기므로, 우리는 하나의 약속을 했다. 
    //tests(arrA,arrB) (= &arrA[0],&arrB[0])
    //이렇게 배열의 이름만 넣으면, 자동으로 첫번째 인덱스의 주소가 넘어간다. 
  
    // 요약: 1.배열을 함수로 넘겨줄 수 있다.
    // 2. 배열을 함수로 넘겨주면, 배열의 첫 인덱스의 주소값이 넘어간다.
    // 3. 편의를 위해 test(&arrA[0]) 표기는 test(arrA[0]) 와 동일하다고 약속했다. 
    
    // <----test 함수에서 ------->
    // test(int a[5], int b[5]) = 크기 5인 int형 배열~의 "주소"를 받겠다는 뜻. (자동으로 그렇게 됨) 
    // a[5] <= &arrA[0] , b[5] <=&arrB[0]  각 첫번째 주소가 들어간다. 
    // **인자가 int형인 이유: 저장되는 주소값에 해당하는 원본 배열이 int형이기 떄문이다!!
    
    // test(int a[5], int b[5]) // = main에서 보낸 배열의 첫 인덱스의 주소를 넘겨받게 된다. 
    
    // **동일한 선언법 
    // test(int a[5], int* b) // 이렇게 선언해도 된다. (자료형에 별 찍었으니까 주소 들어감. 둘이 같은거임) 
    // test(int a[5]. int* b)
    //                  ㄴ b는 인자 이름. test 함수에서 b에 들어오는 값은 int형 포인트 변수라는 뜻. (주소값) 
    // ㄴ 사전에 약속한대로, 배열을 넘겨줄땐 "첫 인덱스의 주소값" 이 넘어오므로
    // ㄴ a[5]라는 인자에 &arrA[0]이 들어간다.
    // ㄴ 직접 써보고 판단하자. 

    //**int a[5] 와 int* a의 차이 
    //둘 다 a배열의 주소값을 받는 인자라는 뜻이다.
    //1. int a[5], 즉 [n] 은 인자로 들어오는 배열의 크기를 명시하는 용도이며,
    // 인자로 들어오는 배열의 크기가 명확할때, 그 크기만 들어올 때 사용한다.

    //2. int* a의 경우, 인자로 들어오는 것이 배열의 "주소" 라는걸 명시적으로 보여준다. 
    // 인자로 들어오는 배열의 크기를 알 수 없을때 사용한다.

    // 요약: 기능은 동일하나, 가독성을 위해 구분해서 표현한 표기법이다. 

    // 3. 포인터의 주요 사용처. 
    // 포인터는 대체로 배열을 넘길때 쓴다. 
    // 정석적인 방식 (예시로 배열 B라고 가정함) 
    // (B + 1) 
    // ㄴ메모리 주소는 1증가하는거임. 메모리는 해당 변수의 자료형만큼 증가. 
    // (ex. 주소 1증가, 메모리 값은 int 라면 4바이트 증가) 

    // 평범하게 배열처럼 사용하면 됨. 
    // B[2] 이런식으로. 이건 해보고 모르면 질문하기. 

    // 히든: *a++와 (*a)++의 차이
    // C++에는 연산자 우선순위가 있다. 

    int k = 10; // int형 변수 k 선언 후 10이라는 값 할당. 
    int* ptrk; // 주소를 받을 수 있는 포인터 변수 선언. int형 자료를 받아주므로 int로 표기
    int* ptrk = &k; // 변수 k의 주소를 포인터 변수 ptrk에 넣어줌.
    *ptrk = 30; // 원 메모리 k에 접근. 아예 값을 30으로 바꿔줌. 

    //1. *a++의 경우 (++연산자가 최우선)
    *ptrk++; // ptrk(주소값)의 ++을 먼저 실행(메모리 주소 증가) -> 그 증가한 주소를 역참조. (= 다음 메모리값 불러옴)
             // 요약: 포인터(주소)가 이동한 후, 그 위치에 있는 메모리를 불러온다. 

    //2. (*a)++의 경우
    (*ptrk)++; // ptrk를 먼저 역참조 -> 그 메모리를 ++
                // 요약: 먼저 원본 값을 불러온 후, 그 값을 증가한다. 


}
