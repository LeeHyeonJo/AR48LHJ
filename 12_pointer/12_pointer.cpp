// 12_pointer.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
// 포인터!! : 시작값을 알면 모든걸 알 수 있다. 
// 활용해서 여러 값을 return 할 수 있다. 

#include <iostream>
// 함수의 인자로 포인터 값을 받는 것도 가능하다. 
// 포인터를 이용해서 여러개의 값을 return 해주는 효과. 
void test(int* a, int* b)
{
    *a += 1; // 별 찍고 +1 하므로, 정확히는 a 값 자체에 +1이 되는 것이다. 
    *b += 1; // 별 찍고 +1 하므로, 정확히는 b 값 자체에 +1이 되는 것이다. 

    // 여러개의 값을 return 해주는 효과. 왜? :: 인자로 들어오는 값 자체를 수정해주기 때문!
}

void test(int arr[2][3]) // 1.이차원 배열은 인자로 넘길땐 이렇게 넣는게 가장 베이직. 
{
    arr[0][0] = 1;
} 

//이차원 배열을 포인터 변수로 다루는 법은 조금 다르다. 
//배열 포인터 :: 2. 이차원 배열 인자로 넘겨주는 정석. (근데 1번 더 자주쓴다) 

void test(int(*pointer)[3])

//숙제: 돌아가는 방식 그림 그리기 
// [int a][int b][int c] = 12byte
// int(*pointer+1)[3] >> int형 3개 한 줄의 주소를 들고 있음.
// +1 하면 12바이트만큼 증가. 
// ㅁㅁㅁ
// ㅁㅁㅁ <= 여기에 접근. 

{
    pointer[1][2] = 99; 
}

int main()
{
    int Arr[2][3] = {};
    test(Arr); 

    int num = 0; // 정수를 저장할떈 int
    char ch = '\0'; // 문자를 저장할땐 char

    char* pCh = &ch;
    *pCh = 'B';
    //*을 찍으면 해당 주소가 있는 메모리의 값을 불러온다. 

    std::cout << pCh; // 주소출력 
    std::cout << *pCh; // pCh의 값 출력 

    int arrnum[3] = {}; // 정수형을 여러개
    char arrchar[3] = {}; // 문자형을 여러개

    // 메모리의 "주소값"을 저장하고싶을때는 포인터 타입을 사용한다.
    // 사용법: 아래와 같다. 
    // void* p; 

    // p에 int num = 0; 변수의 주소값을 넣고 싶다. 
    // 대입하려는 값 앞에 &를 붙인다. 
    
    // void* p = &num;
    // >> void형은 오직 "주소형" 만 저장할때 사용한다. *역참조 안할때 
    int* p = &num; 
    // num의 주소: 0x0000009e1ad3f4f4
    // 16진수로 표현한다. (주소라는 걸 쉽게 알아보라고 약속함) 
    // ㄴ 정수임. 따라서 포인트 변수는 4바이트 크기임. (32비트 운영체제 기준) / 64비트 운영체제 기준으로는 8바이트. 


    //1. 포인터의 기능 : 역참조 연산 
    // ㄴ일반 변수와는 다른 특별한 기능. 

    //1-1. 사용법. 
    // 주의사항: 불러오려는 변수(int num = 0;) 와 동일한 자료형으로맞춰야 한다. 
    // 그 바이트 값 만큼만 불러오기 때문임. 
    * p = 100; // 0이였던 num에 100을 넣은것. 


    // 2. 포인터 변수를 함수로 활용
    int d = 0;
    int e = 0;
    test(&d, &e);

    // return값이 2개 이상 나오는 문제는 포인터로 해결할 것. 
    //일차원 배열을 포인터로 전달하는 법은 하단에./
    // <-------main 에서 ---------->
    // test(arrA,arrB) 호출 & 
    // 
    //tests(arrA,arrB) (= &arrA[0],&arrB[0])
    //>> test 함수에 인자로 전달되는 변수는 값이 복사되지만.
    // 배열은 배열의 주소가, 정확히는 첫번째 인덱스의 주소가 복사된다. (원본이 옮겨감) 
    //  (= &arrA[0],&arrB[0]) 라고 넣어주는게 정석이지만, 매번 쓰기 번거롭기 때문에
    // arrA, 이렇게 쓰면 첫번째 인덱스의 주소값이라고 보기로 약속했다.
    

    // <----test 함수에서 ------->
    // test(int a[5], int b[5]) // = b배열의 첫 인덱스의 주소가 들어감. 
    // test(int a[5], int* b) // 이렇게 선언해도 된다. (자료형에 별 찍었으니까 주소 들어감. 둘이 같은거임) 

    // int* b 와 int *b는 다르다... 

    // 포인터는 대체로 배열을 넘길때 쓴다. 
    // 정석적인 방식 (예시로 배열 B라고 가정함) 
    // (B + 1) 
    // ㄴ메모리 주소는 1증가하는거임. 메모리는 해당 변수의 자료형만큼 증가. 
    // (ex. 주소 1증가, 메모리 값은 int 라면 4바이트 증가) 

    // 평범하게 배열처럼 사용하면 됨. 
    // B[2] 이런식으로. 이건 해보고 모르면 질문하기. 

}
