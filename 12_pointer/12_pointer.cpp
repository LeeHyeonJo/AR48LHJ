// 12_pointer.cpp : 이 파일에는 'main' 함수가 포함됩니다. 거기서 프로그램 실행이 시작되고 종료됩니다.
// 포인터!! : 시작값을 알면 모든걸 알 수 있다. 

#include <iostream>

// 함수의인자로 포인터 값을 받는 것도 가능하다. 
void test(int* a, int* b)
{
    *a += 1; // 별 찍고 +1 하므로, 정확히는 a 값 자체에 +1이 되는 것이다. 
    *b += 1; // 별 찍고 +1 하므로, 정확히는 b 값 자체에 +1이 되는 것이다. 
}

int main()
{
    int num = 0; // 정수를 저장할떈 int
    char ch = '\0'; // 문자를 저장할땐 char

    char* pCh = &ch;
    *pCh = 'B';
    //*을 찍으면 해당 주소가 있는 메모리의 값을 불러온다. 

    std::cout << pCh; // 주소출력 
    std::cout << *pCh; // pCh의 값 출력 

    int arrnum[3] = {}; // 정수형을 여러개
    char arrchar[3] = {}; // 문자형을 여러개

    // 메모리의 "주소값"을 저장하고싶을때는 포인터 타입을 사용한다.
    // 사용법: 아래와 같다. 
    // void* p; 

    // p에 int num = 0; 변수의 주소값을 넣고 싶다. 
    // 대입하려는 값 앞에 &를 붙인다. 
    
    // void* p = &num;
    // >> void형은 오직 "주소형" 만 저장할때 사용한다. *역참조 안할때 
    int* p = &num; 
    // num의 주소: 0x0000009e1ad3f4f4
    // 16진수로 표현한다. (주소라는 걸 쉽게 알아보라고 약속함) 
    // ㄴ 정수임. 따라서 포인트 변수는 4바이트 크기임. 


    //1. 포인터의 기능 : 역참조 연산 
    // ㄴ일반 변수와는 다른 특별한 기능. 

    //1-1. 사용법. 
    // 주의사항: 불러오려는 변수(int num = 0;) 와 동일한 자료형으로맞춰야 한다. 
    // 그 바이트 값 만큼만 불러오기 때문임. 
    * p = 100; // 0이였던 num에 100을 넣은것. 


    // 2. 포인터 변수를 함수로 활용
    int d = 0;
    int e = 0;
    test(&d, &e);
    // return값이 2개 이상 나오는 문제는 포인터로 해결할 것. 
}
